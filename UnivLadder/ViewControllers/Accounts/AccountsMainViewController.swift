//
//  AccountsMainViewController.swift
//  UnivLadder
//
//  Created by leeyeon2 on 2021/12/06.
//

import UIKit
import AuthenticationServices
import GoogleSignIn
import KakaoSDKUser
import Firebase
import Alamofire

// Î°úÍ∑∏Ïù∏ ÌôîÎ©¥
class AccountsMainViewController: UIViewController, ASAuthorizationControllerPresentationContextProviding, ASAuthorizationControllerDelegate, UITextFieldDelegate, StoryboardInitializable {
    
    static var storyboardName: String = "Accounts"
    static var storyboardID: String = "Accounts"
    
    var userModel = UserModel() // Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
    
    let logInError: Int = 0
    var isAutoLogin: Bool = false
    
    @IBOutlet weak var emailTextField: UITextField!
    @IBOutlet weak var passwordTextField: UITextField!
    
    @IBOutlet weak var emailErrorLabel: UILabel!
    @IBOutlet weak var passwordErrorLabel: UILabel!
    @IBOutlet weak var autoLogInCheckmark: UIButton!
    
    @IBOutlet weak var registerBtn: UIButton!
    
    
    @IBOutlet weak var serverLoginBtn: UIButton!
    @IBOutlet weak var googleLogInBtn: UIButton!
    @IBOutlet weak var appleLogInBtn: UIButton!
    @IBOutlet weak var kakaoLoginBtn: UIButton!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.viewComponents()
    }
    
    // MARK: - Î°úÍ∑∏Ïù∏ Action
    //1. ÏûêÏ≤¥ Î°úÍ∑∏Ïù∏ 2.Íµ¨Í∏Ä ÏÜåÏÖú Î°úÍ∑∏Ïù∏ 3.Ïï†Ìîå ÏÜåÏÖú Î°úÍ∑∏Ïù∏
    
    //1. ÏûêÏ≤¥ Î°úÍ∑∏Ïù∏ - ÌÜ†ÌÅ∞ Ï†ÄÏû•(ÌÇ§Ï≤¥Ïù∏)
    // + coredata ÏóÜÎäî Í≤ΩÏö∞ ÎÇ¥ Í≥ÑÏ†ï Ï°∞Ìöå response Í∞í Ï†ÄÏû•
    //    "username" : "sign-in@gmail.com",
    //    "password" : "password"
    
    /// Î°úÍ∑∏Ïù∏ ÏàòÌñâ action Î©îÏÜåÎìú
    /// - Parameter sender: sender
    @IBAction func logInAction(_ sender: Any) {
        // ÏòµÏÖîÎÑê Î∞îÏù∏Îî© & ÏòàÏô∏ Ï≤òÎ¶¨ : TextfieldÍ∞Ä ÎπàÎ¨∏ÏûêÏó¥Ïù¥ ÏïÑÎãàÍ≥†, nilÏù¥ ÏïÑÎãê Îïå
        guard let email = emailTextField.text, !email.isEmpty else { return }
        guard let password = passwordTextField.text, !password.isEmpty else { return }
        
        //        if self.checkLogInInfo(email: email, password: password) {
        self.serverLogIn(email: email, password: password)
        //        }
    }
    
    /// Î°úÍ∑∏Ïù∏ ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ ÌòïÏãù Ï≤¥ÌÅ¨ Î©îÏÜåÎìú
    /// - Parameters:
    ///   - email: Î°úÍ∑∏Ïù∏ Ïù¥Î©îÏùº
    ///   - password: Î°úÍ∑∏Ïù∏ ÎπÑÎ∞ÄÎ≤àÌò∏
    /// - Returns: bool type, true Ïù∏ Í≤ΩÏö∞ ÏÑúÎ≤Ñ ÌÜµÏã† ÏàòÌñâ
    func checkLogInInfo(email: String, password: String) -> Bool {
        var res = false
        
        // Ïù¥Î©îÏùº ÌòïÏãù Ïò§Î•ò
        if userModel.isValidEmail(id: email){
            //nil Ï≤òÎ¶¨ Ï∂îÍ∞Ä
            //emailErrorLabel.text = " "
            if let removable = self.view.viewWithTag(100) {
                removable.removeFromSuperview()
                res = true
            }
        }
        else {
            shakeTextField(textField: emailTextField)
            emailErrorLabel.text = "ÏûòÎ™ªÎêú ÌòïÏãùÏùò Ïù¥Î©îÏùºÏûÖÎãàÎã§."
            emailErrorLabel.textColor = UIColor.red
            emailErrorLabel.tag = 100
            emailErrorLabel.isHidden = false
            res = false
        }
        
        // ÎπÑÎ∞ÄÎ≤àÌò∏ ÌòïÏãù Ïò§Î•ò
        if userModel.isValidPassword(pwd: password){
            if let removable = self.view.viewWithTag(101) {
                removable.removeFromSuperview()
                res = true
            }
        }
        else{
            shakeTextField(textField: passwordTextField)
            passwordErrorLabel.text = "ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Îã§Ïãú ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."
            passwordErrorLabel.textColor = UIColor.red
            passwordErrorLabel.tag = 101
            passwordErrorLabel.isHidden = false
            res = false
        }
        return res
    }
    
    
    func serverLogIn(email: String, password: String) {
        //Ïã§ data
        let params = ["username" : email,
                      "password" : password]
        
        APIService.shared.signIn(param: params, completion: {
            if let accessToken = UserDefaults.standard.string(forKey: "accessToken") {
                
                // ÏûêÎèô Î°úÍ∑∏Ïù∏ ÏÑ§Ï†ï Í∞í Ï†ÄÏû•
                if self.isAutoLogin == true {
                    UserDefaults.standard.setValue(true, forKey: "isAutoLogin")
                }else{
                    UserDefaults.standard.setValue(false, forKey: "isAutoLogin")
                }
                
                // Ï∂îÏ≤ú Î©òÌÜ† Ï†ïÎ≥¥ Î∂àÎü¨Ïò¥
                APIService.shared.getRecommendMentors(accessToken: accessToken)
                
                // ÌÇ§Ï≤¥Ïù∏ Ï†ÄÏû•
                if KeyChain.shared.addItem(id: "accessToken", token: accessToken){
                    print("ÌÜ†ÌÅ∞ : \(accessToken)")
                }else{
                    print("üëøÌÇ§Ï≤¥Ïù∏ Ï†ÄÏû• Ïã§Ìå®üëø")
                }
                
                // Ïú†Ï†ÄÏùò Ï±ÑÌåÖ Î¶¨Ïä§Ìä∏ Î∂àÎü¨Ïò§Í∏∞
                DispatchQueue.global().async {
                    APIService.shared.getDirectListMessage(accessToken: accessToken, completion: { res in
                        
                    })
                }

                
                // ÎÇ¥ Í≥ÑÏ†ï Ï°∞Ìöå
                APIService.shared.getMyAccount(accessToken: accessToken, completion: { accountId in
                    UserDefaults.standard.setValue(accountId, forKey: "accountId")
                    // Î©îÏù∏ÌôîÎ©¥ Ïù¥Îèô
                    if accountId > 0 {
                        UIViewController.changeRootViewControllerToHome()
                        // FCM ÌÜ†ÌÅ∞ Ï†ÄÏû•
                        if let fcmToken = UserDefaults.standard.string(forKey: "fcmToken") {
                            APIService.shared.putFCMToken(fcmToken: fcmToken, accessToken: accessToken, accountId: accountId)
                            print("accountId = \(accountId)")
                        }
                    }
                })
            }else{
                let alert = UIAlertController(title:"üëøÎ°úÍ∑∏Ïù∏ Ïã§Ìå®üëø",
                                              message: "Î°úÍ∑∏Ïù∏ Ï†ïÎ≥¥Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.",
                                              preferredStyle: UIAlertController.Style.alert)
                let buttonLabel = UIAlertAction(title: "ÌôïÏù∏", style: .default, handler: nil)
                alert.addAction(buttonLabel)
                self.present(alert,animated: true,completion: nil)
            }
        })
    }
    
    // ÏûêÎèô Î°úÍ∑∏Ïù∏ Ïï°ÏÖò
    @IBAction func autoLoginAction(_ sender: UIButton) {
        // auto login ÏÑ†ÌÉù Ïó¨Î∂Ä
        sender.isSelected = !sender.isSelected
        if sender.isSelected == true{
            // ÏûêÎèô Î°úÍ∑∏Ïù∏ Ïã§Ìñâ
            self.isAutoLogin = true
            autoLogInCheckmark.setImage(UIImage(named: "checkBoxFilled.png"), for: .normal)
        }else{
            //ÏûêÎèô Î°úÍ∑∏Ïù∏ ÏïàÌï®
            self.isAutoLogin = false
            autoLogInCheckmark.setImage(UIImage(named: "checkBox.png"), for: .normal)
        }
    }
    
    // TextField ÌùîÎì§Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò
    func shakeTextField(textField: UITextField) -> Void{
        UIView.animate(withDuration: 0.2, animations: {
            textField.frame.origin.x -= 10
        }, completion: { _ in
            UIView.animate(withDuration: 0.2, animations: {
                textField.frame.origin.x += 20
            }, completion: { _ in
                UIView.animate(withDuration: 0.2, animations: {
                    textField.frame.origin.x -= 20
                })
            })
        })
    }
    
    fileprivate func saveNewUser(_ accountId: Int, email: String, gender: String, name: String, password: String, thumbnail: String?, mentee: Bool, mentor: Bool) {
        CoreDataManager.shared
            .saveUserEntity(accountId: accountId, email: email, gender: gender, name: name, password: password, thumbnail: thumbnail, mentee: mentee, mentor: mentor,  onSuccess: { onSuccess in
                UIViewController.changeRootViewControllerToHome()
            })
        User.name = name
    }
    
    //ÏÜåÏÖú Î°úÍ∑∏Ïù∏ - 1. Ïπ¥Ïπ¥Ïò§
    @IBAction func kakaoLogInAction(_ sender: Any) {
        // ÏûêÎèô Î°úÍ∑∏Ïù∏ ÏÑ§Ï†ï Í∞í Ï†ÄÏû•
        if self.isAutoLogin == true {
            UserDefaults.standard.setValue(true, forKey: "isAutoLogin")
        }else{
            UserDefaults.standard.setValue(false, forKey: "isAutoLogin")
        }
        
        // Ïπ¥Ïπ¥Ïò§ÌÜ° ÏÑ§Ïπò Ïó¨Î∂Ä ÌôïÏù∏
        if (UserApi.isKakaoTalkLoginAvailable()) {
            UserApi.shared.loginWithKakaoTalk {(oauthToken, error) in
                if let error = error {
                    print(error)
                }
                else {
                    if let oauthToken = oauthToken{
                        LoginDataModel.token = oauthToken.accessToken
                        // kakaotalk login post
                        APIService.shared.signinSocial(param: LoginDataModel.registeParam, domain: "kakao", completion: { restoken in
                            APIService.shared.getMyAccount(accessToken: restoken, completion: { accountId in
                                UserDefaults.standard.setValue(accountId, forKey: "accountId")
                                self.getKakaoAccount(completion: { myEmail, myNickName   in
                                    // Ïù¥Î¶Ñ, Ïù¥Î©îÏùº Ï†ÄÏû•
                                    let parameter: Parameters = [
                                        "email": myEmail ?? "",
                                        "name" : myNickName ?? "",
                                    ]
                                    
                                    APIService.shared.modifyMyAccount(accessToken: restoken,
                                                                      accountId: UserDefaults.standard.integer(forKey: "accountId"),
                                                                      param: parameter,
                                                                      completion: { res in
                                        CoreDataManager.shared.deleteAllUsers()
                                        self.saveNewUser(accountId,
                                                         email: myEmail,
                                                         gender: "",
                                                         name: myNickName,
                                                         password: "",
                                                         thumbnail: "",
                                                         mentee: true,
                                                         mentor: false
                                        )
                                    })
                                })
                            })
                        })
                        print("kakao accessToken : \(oauthToken.accessToken)")
                    } else {
                        print("Error : User Data Not Found")
                    }
                }
            }
        }
    }
    
    // Ïπ¥Ïπ¥Ïò§ Í≥ÑÏ†ï Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    func getKakaoAccount(completion: @escaping (String, String) -> Void) {
        var myEmail = ""
        var myNickName = ""
        
        UserApi.shared.me() {(user, error) in
            if let error = error {
                print(error)
            }
            else {
                _ = user
                if let email = user?.kakaoAccount?.email{
                    myEmail = email
                }
                if let nickName = user?.kakaoAccount?.profile?.nickname{
                    myNickName = nickName
                }
                completion(myEmail, myNickName)
            }
        }
    }
    
    //ÏÜåÏÖú Î°úÍ∑∏Ïù∏ - 2. Íµ¨Í∏Ä
    @IBAction func googleLogInAction(_ sender: Any) {
        // ÏûêÎèô Î°úÍ∑∏Ïù∏ ÏÑ§Ï†ï Í∞í Ï†ÄÏû•
        if self.isAutoLogin == true {
            UserDefaults.standard.setValue(true, forKey: "isAutoLogin")
        }else{
            UserDefaults.standard.setValue(false, forKey: "isAutoLogin")
        }
        
        // GIDSignIn config Í∞ùÏ≤¥ ÏÑ§Ï†ï
        guard let clientID = FirebaseApp.app()?.options.clientID else { return }
        let config = GIDConfiguration(clientID: clientID)
        GIDSignIn.sharedInstance.configuration = config
        GIDSignIn.sharedInstance.signIn(withPresenting: self) { [weak self] signInResult, _ in
            guard let self,
                  let result = signInResult,
                  let token = result.user.idToken?.tokenString,
                  let email = result.user.profile?.email,
                  let nickName = result.user.profile?.name
                    
            else { return }
            // ÏÑúÎ≤ÑÏóê ÌÜ†ÌÅ∞ÏùÑ Î≥¥ÎÇ¥Í∏∞. Ïù¥ Îïå idToken, accessToken Ï∞®Ïù¥Ïóê Ï£ºÏùòÌï† Í≤É
            LoginDataModel.token = token
            // google login post
            APIService.shared.signinSocial(param: LoginDataModel.registeParam, domain: "google", completion: { restoken in
                APIService.shared.getMyAccount(accessToken: restoken, completion: { accountId in
                    UserDefaults.standard.setValue(accountId, forKey: "accountId")
                    // Ïù¥Î¶Ñ, Ïù¥Î©îÏùº Ï†ÄÏû•
                    let parameter: Parameters = [
                        "email": email ?? "",
                        "name" : nickName ?? "",
                    ]
                    
                    APIService.shared.modifyMyAccount(accessToken: restoken,
                                                      accountId: UserDefaults.standard.integer(forKey: "accountId"),
                                                      param: parameter,
                                                      completion: { res in
                        CoreDataManager.shared.deleteAllUsers()
                        self.saveNewUser(accountId,
                                         email: email,
                                         gender: "",
                                         name: nickName,
                                         password: "",
                                         thumbnail: "",
                                         mentee: true,
                                         mentor: false
                        )
                    })
                })
            })
        }
    }
    
    
    //ÏÜåÏÖú Î°úÍ∑∏Ïù∏ - 3. Ïï†Ìîå
    @IBAction func appleLogIn(_ sender: Any) {
        // ÏûêÎèô Î°úÍ∑∏Ïù∏ ÏÑ§Ï†ï Í∞í Ï†ÄÏû•
        if self.isAutoLogin == true {
            UserDefaults.standard.setValue(true, forKey: "isAutoLogin")
        }else{
            UserDefaults.standard.setValue(false, forKey: "isAutoLogin")
        }
        
        let appleIDProvider = ASAuthorizationAppleIDProvider()
        let request = appleIDProvider.createRequest()
        request.requestedScopes = [.fullName, .email]
        
        let authorizationController = ASAuthorizationController(authorizationRequests: [request])
        authorizationController.delegate = self
        authorizationController.presentationContextProvider = self
        authorizationController.performRequests()
    }
    
    func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
        return self.view.window!
    }
    
    // Apple ID Ïó∞Îèô ÏÑ±Í≥µ Ïãú
    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
        switch authorization.credential {
            // Apple ID
        case let appleIDCredential as ASAuthorizationAppleIDCredential:
            
            // Í≥ÑÏ†ï Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
            // Ïï†ÌîåÏùÄ ÏµúÏ¥à Î°úÍ∑∏Ïù∏ÎïåÎßå Ï†ïÎ≥¥ Ï§å;;
            let userIdentifier = appleIDCredential.user
            let fullName = appleIDCredential.fullName
            let email = appleIDCredential.email
            
            // accessToken (Data -> ÏïÑÏä§ÌÇ§ Ïù∏ÏΩîÎî© -> Ïä§Ìä∏ÎßÅ)
            let accessToken = String(data: appleIDCredential.identityToken!, encoding: .ascii) ?? ""
            LoginDataModel.token = accessToken
            
            // apple login post
            //
            APIService.shared.signinSocial(param: LoginDataModel.registeParam, domain: "apple", completion: { res in
                APIService.shared.getMyAccount(accessToken: res, completion: { accountId in
                    UserDefaults.standard.setValue(accountId, forKey: "accountId")
                    
                    // Ïù¥Î¶Ñ, Ïù¥Î©îÏùº Ï†ÄÏû•
                    let parameter: Parameters = [
                        "email": "\(email ?? "")",
                        "name" : "\((fullName?.givenName ?? "") + (fullName?.familyName ?? ""))",
                    ]
                    
                    APIService.shared.modifyMyAccount(accessToken: accessToken,
                                                      accountId: UserDefaults.standard.integer(forKey: "accountId"),
                                                      param: parameter,
                                                      completion: { res in
                        CoreDataManager.shared.deleteAllUsers()
                        self.saveNewUser(accountId,
                                         email: "\(email ?? "")",
                                         gender: "",
                                         name: "\((fullName?.givenName ?? "") + (fullName?.familyName ?? ""))",
                                         password: "",
                                         thumbnail: "",
                                         mentee: true,
                                         mentor: false
                        )
                    })
                })
            })
        default:
            break
        }
    }
    
    // Apple ID Ïó∞Îèô Ïã§Ìå® Ïãú - ÏóêÎü¨ÏΩîÎìú Ï†ïÏ†ú ÌïÑÏöî
    func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
        print(error)
        let alert = UIAlertController()
        alert.title = "ERROR"
        
        // Handle error.
        switch logInError{
            // Î≤ÑÏ†ÑÏù¥ 13.0 ÎØ∏ÎßåÏù∏ Í≤ΩÏö∞
        case 1:
            alert.message = "Ïï†Ìîå Î°úÍ∑∏Ïù∏ÏùÄ iOS 13.0 Ïù¥ÏÉÅÎ∂ÄÌÑ∞ Í∞ÄÎä•Ìï©ÎãàÎã§."
        default:
            alert.message = "\(error)"
            break
        }
    }
    
    @IBAction func moveToRegist(_ sender: Any) {
        performSegue(withIdentifier: "toRegist", sender: nil)
    }
    
    // MARK: - View Components
    func viewComponents(){
        serverLoginBtn.layer.cornerRadius = 10
        let imageView = UIImageView();
        let image = UIImage(named: "emailIcon.png");
        imageView.image = image;
        emailTextField.leftView = imageView;
        emailErrorLabel.isHidden = true
        passwordErrorLabel.isHidden = true
        
        //Î°úÍ∑∏Ïù∏ Î≤ÑÌäº
        googleLogInBtn.layer.borderWidth = 1
        googleLogInBtn.layer.borderColor = UIColor.lightGray.cgColor
        googleLogInBtn.layer.cornerRadius = 10
        
        appleLogInBtn.layer.borderWidth = 1
        appleLogInBtn.layer.borderColor = UIColor.lightGray.cgColor
        appleLogInBtn.layer.cornerRadius = 10
        
        kakaoLoginBtn.layer.cornerRadius = 10
        kakaoLoginBtn.layer.borderWidth = 1
        kakaoLoginBtn.layer.borderColor = UIColor.lightGray.cgColor
        if let image = UIImage(named: "KakaoTalk.png") {
            let image2 = image.withRoundedCorners(radius: 15)!
            kakaoLoginBtn.setImage(image2, for: .normal)
        }
        
        //ÌÖçÏä§Ìä∏ÌïÑÎìúBtn.backgroundColor = UIColor.whiteb
        emailTextField.delegate = self
        passwordTextField.delegate = self
        emailTextField.clearsOnBeginEditing = true
        passwordTextField.clearsOnBeginEditing = true
        self.emailTextField.addTarget(self, action: #selector(self.textFieldDidChange1(_:)), for: .editingChanged)
        self.passwordTextField.addTarget(self, action: #selector(self.textFieldDidChange2(_:)), for: .editingChanged)
        
        //        emailTextField.addleftimage(image: UIImage(named: "emailIcon.png")!)
        
        //ÌÇ§Ìå®Îìú Ï†úÏñ¥
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(keyboardWillHide(_:)),
                                               name: UIResponder.keyboardWillHideNotification,
                                               object: nil)
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(keyboardWillShow(_:)),
                                               name: UIResponder.keyboardWillShowNotification,
                                               object: nil)
        
        
    }
    //ÌÇ§Î≥¥Îìú Ïò¨ÎùºÍ∞îÎã§Îäî ÏïåÎ¶ºÏùÑ Î∞õÏúºÎ©¥ Ïã§ÌñâÎêòÎäî Î©îÏÑúÎìú
    @objc func keyboardWillShow(_ sender:Notification){
        self.view.frame.origin.y = -80
    }
    //ÌÇ§Î≥¥Îìú ÎÇ¥Î†§Í∞îÎã§Îäî ÏïåÎ¶ºÏùÑ Î∞õÏúºÎ©¥ Ïã§ÌñâÎêòÎäî Î©îÏÑúÎìú
    @objc func keyboardWillHide(_ sender:Notification){
        self.view.frame.origin.y = 0
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?){
        self.view.endEditing(true)
    }
    func textFieldShouldReturn(_ textField: UITextField) -> Bool{
        textField.resignFirstResponder()
        return true
    }
    //ÌÖçÏä§Ìä∏ÌïÑÎìú Í∞í Î≥ÄÍ≤Ω Í∞êÏßÄ
    @objc func textFieldDidChange1(_ sender: Any?) {
        emailTextField.clearsOnBeginEditing = false
    }
    @objc func textFieldDidChange2(_ sender: Any?) {
        passwordTextField.clearsOnBeginEditing = false
    }
}


@IBDesignable
class DesignableUITextField: UITextField {
    
    // Provides left padding for images
    override func leftViewRect(forBounds bounds: CGRect) -> CGRect {
        var textRect = super.leftViewRect(forBounds: bounds)
        textRect.origin.x += leftPadding
        return textRect
    }
    
    @IBInspectable var leftImage: UIImage? {
        didSet {
            updateView()
        }
    }
    
    @IBInspectable var leftPadding: CGFloat = 0
    
    @IBInspectable var color: UIColor = UIColor.lightGray {
        didSet {
            updateView()
        }
    }
    
    func updateView() {
        if let image = leftImage {
            leftViewMode = UITextField.ViewMode.always
            let imageView = UIImageView(frame: CGRect(x: 0, y: 0, width: 20, height: 20))
            imageView.contentMode = .scaleAspectFit
            imageView.image = image
            imageView.tintColor = color
            leftView = imageView
        } else {
            leftViewMode = UITextField.ViewMode.never
            leftView = nil
        }
        
        // Placeholder text color
        attributedPlaceholder = NSAttributedString(string: placeholder != nil ?  placeholder! : "", attributes:[NSAttributedString.Key.foregroundColor: color])
    }
}

extension UIImage {
    // image with rounded corners
    public func withRoundedCorners(radius: CGFloat? = nil) -> UIImage? {
        let maxRadius = min(size.width, size.height) / 2
        let cornerRadius: CGFloat
        if let radius = radius, radius > 0 && radius <= maxRadius {
            cornerRadius = radius
        } else {
            cornerRadius = maxRadius
        }
        UIGraphicsBeginImageContextWithOptions(size, false, scale)
        let rect = CGRect(origin: .zero, size: size)
        UIBezierPath(roundedRect: rect, cornerRadius: cornerRadius).addClip()
        draw(in: rect)
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return image
    }
    
}
